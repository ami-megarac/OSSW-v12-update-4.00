--- linux_patch318/include/net/af_unix.h	2020-04-01 11:18:09.573961458 +0800
+++ linux/include/net/af_unix.h	2020-04-06 15:44:25.988164552 +0800
@@ -6,8 +6,8 @@
 #include <linux/mutex.h>
 #include <net/sock.h>
 
-void unix_inflight(struct file *fp);
-void unix_notinflight(struct file *fp);
+void unix_inflight(struct user_struct *user, struct file *fp);
+void unix_notinflight(struct user_struct *user, struct file *fp);
 void unix_gc(void);
 void wait_for_unix_gc(void);
 struct sock *unix_get_socket(struct file *filp);
--- linux_patch318/include/net/scm.h	2020-04-01 11:18:09.673961383 +0800
+++ linux/include/net/scm.h	2020-04-06 15:45:42.244191354 +0800
@@ -21,6 +21,7 @@
 struct scm_fp_list {
 	short			count;
 	short			max;
+	struct user_struct *user;
 	struct file		*fp[SCM_MAX_FD];
 };
 
--- linux_patch318/net/core/scm.c	2020-04-01 11:14:16.598138997 +0800
+++ linux/net/core/scm.c	2020-04-06 15:49:37.320259563 +0800
@@ -87,6 +87,7 @@
 		*fplp = fpl;
 		fpl->count = 0;
 		fpl->max = SCM_MAX_FD;
+		fpl->user = NULL;
 	}
 	fpp = &fpl->fp[fpl->count];
 
@@ -107,6 +108,10 @@
 		*fpp++ = file;
 		fpl->count++;
 	}
+
+	if (!fpl->user)
+		fpl->user = get_uid(current_user());
+
 	return num;
 }
 
@@ -119,6 +124,7 @@
 		scm->fp = NULL;
 		for (i=fpl->count-1; i>=0; i--)
 			fput(fpl->fp[i]);
+		free_uid(fpl->user);
 		kfree(fpl);
 	}
 }
@@ -335,6 +341,7 @@
 		for (i = 0; i < fpl->count; i++)
 			get_file(fpl->fp[i]);
 		new_fpl->max = new_fpl->count;
+		new_fpl->user = get_uid(fpl->user);
 	}
 	return new_fpl;
 }
--- linux_patch318/net/unix/af_unix.c	2020-04-01 11:14:28.858129480 +0800
+++ linux/net/unix/af_unix.c	2020-04-06 15:52:56.712212798 +0800
@@ -1466,7 +1466,7 @@
 	UNIXCB(skb).fp = NULL;
 
 	for (i = scm->fp->count-1; i >= 0; i--)
-		unix_notinflight(scm->fp->fp[i]);
+		unix_notinflight(scm->fp->user, scm->fp->fp[i]);
 }
 
 static void unix_destruct_scm(struct sk_buff *skb)
@@ -1532,7 +1532,7 @@
 
 	if (unix_sock_count) {
 		for (i = scm->fp->count - 1; i >= 0; i--)
-			unix_inflight(scm->fp->fp[i]);
+			unix_inflight(scm->fp->user, scm->fp->fp[i]);
 	}
 	return max_level;
 }
--- linux_patch318/net/unix/garbage.c	2020-04-01 11:14:28.766129553 +0800
+++ linux/net/unix/garbage.c	2020-04-06 15:55:03.840184157 +0800
@@ -122,7 +122,7 @@
  *	descriptor if it is for an AF_UNIX socket.
  */
 
-void unix_inflight(struct file *fp)
+void unix_inflight(struct user_struct *user, struct file *fp)
 {
 	struct sock *s = unix_get_socket(fp);
 	
@@ -138,11 +138,11 @@
 		}
 		unix_tot_inflight++;
 	}
-	fp->f_cred->user->unix_inflight++;
+	user->unix_inflight++;
 	spin_unlock(&unix_gc_lock);
 }
 
-void unix_notinflight(struct file *fp)
+void unix_notinflight(struct user_struct *user, struct file *fp)
 {
 	struct sock *s = unix_get_socket(fp);
 	
@@ -156,7 +156,7 @@
 		unix_tot_inflight--;
 
 	}
-	fp->f_cred->user->unix_inflight--;
+	user->unix_inflight--;
 	spin_unlock(&unix_gc_lock);
 }
 
